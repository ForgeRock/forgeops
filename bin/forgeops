#!/usr/bin/env bash

set -e

# Grab our starting dir
start_dir=$(pwd)
# Figure out the dir we live in
SCRIPT_DIR=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )
# Bring in our standard functions
source $SCRIPT_DIR/../lib/shell/stdlib.sh

usage() {
  prog=$(basename $0)

  ! read -r -d '' usage_msg <<- EOM
  Usage:
  $prog COMMAND [OPTIONS] [<component> <component> ...]

  Central interface to the scripts in commands folder. Use -h with any command
  to see its usage.

  OPTIONS:
  -h|--help                 : display usage and exit
  --debug                   : turn on debugging
  --dryrun                  : do a dry run

  Commands: ${COMMANDS[@]}
  Deprecated Commands: ${COMMANDS_DEPRECATED[@]}

EOM

  usageStd $1 "$usage_msg" "$2"

}

source_cfg() {
  local cfg=$1
  if [ -f "$cfg" ] ; then
    set -a
    source $cfg
    set +a
  fi
}

change_root_to_data() {
  echo "The FORGEOPS_ROOT env var has been renamed to FORGEOPS_DATA."
  read -n 1 -p "Would you like me to update $FORGEOPS_CFG_USER for you? (Y/N)" response
  if [ "$response" == "y" ] || [ "$response" == "Y" ] ; then
    sed_cmd=$(type -P sed)
    if [ -x "$sed_cmd" ] ; then
      runOrPrint "$sed_cmd -i -e 's,FORGEOPS_ROOT,FORGEOPS_DATA,' $FORGEOPS_CFG_USER"
      source_cfg $FORGEOPS_CFG_USER
      return
    else
      echo "Unable to update $FORGEOPS_CFG_USER because no sed is available."
    fi
  fi
  echo "Please update your forgeops.conf file(s)."
  FORGEOPS_DATA=$FORGEOPS_ROOT
}

DEBUG=false
DRYRUN=false
VERBOSE=false

# Since we want to see dryruns for both this script and the called script,
# setting RUNANDPRINT to true so the sub script gets called.
RUNANDPRINT=true

ARG_ARRAY=("$@") # Create an array out of our arguments

COMMANDS=(
  'amster'
  'apply'
  'upgrade-am-config'
  'build'
  'configure'
  'config'
  'delete'
  'env'
  'info'
  'image'
  'prereqs'
  'rotate'
  'version'
  'wait'
)

COMMANDS_DEPRECATED=(
  'clean'
  'install'
)

# Avoiding our pattern of looping and shifting ARG elements as we want to
# pass those as is to the worker scripts.

COMMAND=$1 # Our first arg should be the command

# We need to detect --dryrun and --debug.
if containsElement '--debug' "${ARG_ARRAY[*]}" ; then
  DEBUG=true
fi

if containsElement '--dryrun' "${ARG_ARRAY[*]}" ; then
  DRYRUN=true
fi

message "COMMAND=$COMMAND" "debug"
message "DEBUG=$DEBUG" "debug"
message "DRYRUN=$DRYRUN" "debug"

message "Validating command: $COMMAND" "debug"
if containsElement "$COMMAND" "${COMMANDS[*]}" ; then
  message "Valid command: $COMMAND" "debug"
  VALID_COMMAND=true
elif containsElement "$COMMAND" "${COMMANDS_DEPRECATED[*]}" ; then
  message "Deprecated command: $COMMAND" "debug"
  VALID_COMMAND=true
else
  VALID_COMMAND=false
fi
message "VALID_COMMAND=$VALID_COMMAND" "debug"

HELP_FLAGS=('-h' '--help')
if [ "$VALID_COMMAND" = false ] && containsElements "${HELP_FLAGS[*]}" "${ARG_ARRAY[*]}" ; then
  usage 0
elif [ "$VALID_COMMAND" = false ] ; then
  usage 1 "Invalid command: $COMMAND"
else
  message "Removing $COMMAND from arguments" "debug"
  shift
fi

source_cfg "$SCRIPT_DIR/../forgeops.conf"

FORGEOPS_CFG_USER="${HOME}/.forgeops.conf"
source_cfg $FORGEOPS_CFG_USER

if [ -n "$FORGEOPS_ROOT" ] ; then
  change_root_to_data
fi

if [ -n "$FORGEOPS_DATA" ] ; then
  source_cfg "$FORGEOPS_DATA/forgeops.cfg"
  source_cfg $FORGEOPS_CFG_USER # Make sure the user's settings are paramount
fi

# Make sure "forgeops configure" has been run before running any commands
if [ "${COMMAND}" != "configure" ] ; then
  if ! python3 "${SCRIPT_DIR}/../lib/python/ensure_configuration_is_valid_or_exit.py" ; then
    exit 1
  fi
fi
runOrPrint "$SCRIPT_DIR/commands/${COMMAND} $*"
