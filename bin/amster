#!/usr/bin/python3
# Script to import or export dynamic configuration files from AM using an amster Kubernetes job.
# This must be run in the same namespace as AM. The amster pod expects to find the amster secret key
# (generated by secret agent) in the namespace.
import argparse
import os
import subprocess
import sys
import time

parser = argparse.ArgumentParser(
    description='amster import or export json configuration files')

parser.add_argument(
    '-n', '--namespace', help='The namespace that AM is running in (default is the current namespace context)')
subparser = parser.add_subparsers(dest='cmd')
parser_import = subparser.add_parser(
    'import', help='import json configuration files into AM')
parser_import.add_argument('src', help='Source file or directory to import')
parser_export = subparser.add_parser('export', help='Export files from amster')
parser_export.add_argument('--global', dest='glob', action='store_true', help='Include the global/ configuration in the amster export')
parser_clean = subparser.add_parser('clean', help='Clean up and remove any amster pods')

parser_export.add_argument(
    'dst', help='destination directory to export files to')

args = parser.parse_args()

if args.cmd == None:
    parser.print_help()
    sys.exit(1)

# Namespace for kubectl.
namespace = '' if args.namespace == None else f'--namespace {args.namespace}'

kustomize_dir = os.path.join(sys.path[0], '../kustomize')
amster_upload_job = os.path.join(kustomize_dir, 'base/amster-upload')
amster_export_job = os.path.join(kustomize_dir,'base/amster-export')


def kubectl(command):
    args = f'kubectl {namespace} {command}'
    print(args)
    r = subprocess.run(args.split())
    return r.returncode

def get_pod_name(label):
    cmd = f'kubectl {namespace} get pod -l {label} --output=jsonpath={{.items[0].metadata.name}}'
    print(cmd)
    r = subprocess.run(cmd, shell=True,  capture_output=True)

    if r.returncode != 0:
        print(f'could not get pod name for {label}. {r.stdout} err: {r.stderr}  ')
        sys.exit(r.returncode)

    pod = r.stdout.decode("utf-8")

    # Simple heuristic to look for a malformed pod string being returned from the kubectl command.
    if not pod or len(pod) < 6 or len(pod) > 25:
        print(
            f'Cant get pod. Name does not look correct. err = {r.stderr} stat={r.returncode}')
        sys.exit(1)
    return pod

def wait_pod_ready(pod):
    print( f'Waiting for pod {pod}')
    cmd = f'kubectl {namespace} wait --for=condition=ready pod {pod} --timeout=90s'
    print(cmd)
    r = subprocess.run(cmd, shell=True,  capture_output=True)


# Launch an amster job specified. Provide the path to the kustomize for the amster job. Returns the pod name.
def launch_amster_job(kustomize_path):
    # Surpress the output so we don't log errors in case the job does not exist.
    print('Cleaning up any previous amster jobs...')
    subprocess.run(f'kubectl {namespace} delete job amster',
                   shell=True, capture_output=True)

    print("starting the amster job")
    cmd = f'kustomize build {kustomize_path} | kubectl {namespace} apply -f -'
    print(cmd)
    subprocess.run(cmd,shell=True)
    time.sleep(15) # Give the new pod time to launch, and make sure any old pods have time to terminate
    pod = get_pod_name('app=amster')
    return pod

if args.cmd == 'clean':
        kubectl('delete job amster')
        sys.exit(0)

# Import files into amster.
if args.cmd == 'import':
    # If the source dir/file does not exist exit
    src = args.src
    if not os.path.exists(src):
        print(f'Cant read path {src}')
        sys.exit(1)
    pod = launch_amster_job(amster_upload_job)

    cpstat = 0
    # Copy the src files up to waiting amster pod
    for i in range(5):
        print('uploading files to the pod')
        cpstat = kubectl(f'cp -c amster {src} {pod}:/opt/amster/config/upload')
        if cpstat == 0:
            break;
        print('The cp failed. Will try again')
        time.sleep(10)

    if cpstat != 0:
        print('Could not upload files to the amster pod')
        sys.exit(1)

    print('Waiting for amster job to complete')
    stat = kubectl("wait --for=condition=complete job/amster --timeout=60s")
    kubectl(f'logs -c amster {pod}')
    if stat !=0:
        print('amster import did not complete OK')
        sys.exit(1)

    kubectl('delete job amster')
    sys.exit(0)


# Export files out of amster
if args.cmd == 'export':
    if not os.path.isdir(args.dst):
        print(f'dst {args.dst} is not a directory')
        sys.exit(1)

    # Create export - amster will export data, and wait.
    pod = launch_amster_job(amster_export_job)
    wait_pod_ready(pod)

    # If args.glob is True, copy the realm AND global data
    if args.glob:
        kubectl(f'cp {pod}:/var/tmp/amster {args.dst}')
    else:
        kubectl(f'cp {pod}:/var/tmp/amster/realms {args.dst}/realms')

    if not os.listdir(args.dst):
        print('No files found!')
        sys.exit(1)
    kubectl('delete job amster')

    sys.exit(0)