#!/usr/bin/python3
# Script to import or export dynamic configuration files from AM using an amster Kubernetes job.
# This must be run in the same namespace as AM. The amster pod expects to find the amster secret key
# (generated by secret agent) in the namespace.
import argparse
import os
import subprocess
import sys
import time

parser = argparse.ArgumentParser(
    description='amster import or export json configuration files')

parser.add_argument(
    '-n', '--namespace', help='The namespace that AM is running in (default is the current namespace context)')
subparser = parser.add_subparsers(dest='cmd')
parser_import = subparser.add_parser(
    'import', help='import json configuration files into AM')
parser_import.add_argument('src', help='Source file or directory to import')
parser_export = subparser.add_parser('export', help='Export files from amster')
parser_export.add_argument('--global', dest='glob', action='store_true', help='Include the global/ configuration in the amster export')
parser_clean = subparser.add_parser('clean', help='Clean up and remove any amster pods')

parser_export.add_argument(
    'dst', help='destination directory to export files to')

args = parser.parse_args()

if args.cmd == None:
    parser.print_help()
    sys.exit(1)

# Namespace for kubectl.
namespace = '' if args.namespace == None else f'--namespace {args.namespace}'

kustomize_dir = os.path.join(sys.path[0], '../kustomize')
amster_upload_job = os.path.join(kustomize_dir, 'base/amster-upload')
amster_export_job = os.path.join(kustomize_dir,'base/amster-export')


def kubectl(command):
    args = f'kubectl {namespace} {command}'
    print(args)
    r = subprocess.run(args.split())
    return r.returncode

# Launch an amster job specified by the path to the kustomize. Return the pod name.
# The amster job always pauses - to wait for files to be uploaded, or to wait for files to be downloaded.
def launch_amster_job(kustomize_path):
    # Surpress the output so we don't log errors in case the job does not exist.
    subprocess.run(f'kubectl {namespace} delete job amster',
                   shell=True, capture_output=True)
    print("starting the amster job")
    subprocess.run(
        f'kustomize build {kustomize_path} | kubectl {namespace} apply -f -', shell=True)
    time.sleep(10)
    # Get the pod name for the cp command
    r = subprocess.run(
        "kubectl get pod -l app=amster --output=jsonpath='{.items[0].metadata.name}'", shell=True,  capture_output=True)
    if r.returncode != 0:
        print(f'could not get amster pod name. {r.stdout} err: {r.stderr}  ')
        sys.exit(r.returncode)

    pod = r.stdout.decode("utf-8")

    # Simple heuristic to look for a malformed pod string being returned from the kubectl command.
    if not pod or len(pod) < 6 or len(pod) > 25:
        print(
            f'Cant get pod. Name does not look correct. err = {r.stderr} stat={r.returncode}')
        sys.exit(1)
    return pod

if args.cmd == 'clean':
        kubectl('delete job amster')
        sys.exit(0)

# Import files into amster.
if args.cmd == 'import':
    # If the source dir/file does not exist - sys.exit.
    src = args.src
    if not os.path.exists(src):
        print(f'Cant read path {src}')
        sys.exit(1)
    pod = launch_amster_job(amster_upload_job)

    # Copy the src files up to waiting amster pod
    kubectl(f'cp {src} {pod}:/opt/amster/config/upload')
    print('Waiting for amster job to complete')
    stat = kubectl("wait --for=condition=complete job/amster --timeout=60s")
    kubectl(f'logs {pod}')
    if stat !=0:
        print('amster import did not complete OK. Will leave amster job/pod running')
        sys.exit(1)

    kubectl('delete job amster')
    sys.exit(0)


# Export files out of amster
if args.cmd == 'export':
    if not os.path.isdir(args.dst):
        print(f'dst {args.dst} is not a directory')
        sys.exit(1)

    # Create export - amster will export data, and wait.
    pod = launch_amster_job(amster_export_job)
    print(f'started amster pod {pod}. Giving amster time to export')
    # TODO: Find a more robust method to check status
    time.sleep(10)
    # If args.glob is True, copy the realm AND global data
    if args.glob:
        kubectl(f'cp {pod}:/var/tmp/amster {args.dst}')
    else:
        kubectl(f'cp {pod}:/var/tmp/amster/realms {args.dst}/realms')

    if not os.listdir(args.dst):
        print('No files found. Will leave amster pod running!')
        sys.exit(1)

    # delete the amster job - this will terminate the sleeping pod as well.
    # subprocess.run(f'kubectl {namespace} delete job amster --force',
    #                shell=True, capture_output=True)
    sys.exit(0)