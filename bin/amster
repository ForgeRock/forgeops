#!/usr/bin/python3
# Script to import or export dynamic configuration files from AM using an amster Kubernetes job.
# This must be run in the same namespace as AM. The amster pod expects to find the amster secret key
# (generated by secret agent) in the namespace.
import argparse
import utils
import os
import sys
import time
import json
import pathlib

USER_PWD_EXPR_RULES = {
    'idm-provisioning.json': '&{idm.provisioning.client.secret|openidm}',
    'idm-resource-server.json': '&{idm.rs.client.secret|password}',
    'resource-server.json': '&{ig.rs.client.secret|password}',
    'oauth2.json': '&{pit.client.secret|password}',
    'ig-agent.json': '&{ig.agent.password|password}',
}

def amster_run(ns):
    utils.message('starting...')
    kustomize_dir = os.path.join(sys.path[0], '..', 'kustomize')
    amster_run_job_path = os.path.join(kustomize_dir, 'overlay/7.0/amster-run')
    try:
        clean_amster_job(ns, False)
        pod = _launch_amster_job(amster_run_job_path, ns)
        utils.message('\nWaiting for amster pod to be running. This can take several minutes.')
        utils.run('kubectl', f'-n {ns} wait --for=condition=ready pod {pod} --timeout=600s')
    finally:
        clean_amster_job(ns, True)

def amster_import(ns, src, printlogs=True):
    kustomize_dir = os.path.join(sys.path[0], '../kustomize')
    amster_upload_job_path = os.path.join(kustomize_dir, 'overlay/7.0/amster-upload')
    # If the source dir/file does not exist exit
    if not os.path.exists(src):
        utils.error(f'Cant read path {src}. Please specify a valid path and try again')
        sys.exit(1)

    try:
        clean_amster_job(ns, False)
        utils.message('Packing and uploading configs')
        envVars = os.environ
        envVars['COPYFILE_DISABLE'] = '1'  #skips "._" files in macOS.
        utils.run('tar', f'-czf amster-import.tar.gz -C {src} .', cstdout=True, env=envVars)
        utils.run('kubectl', f'-n {ns} create cm amster-import --from-file=amster-import.tar.gz')
        pod = _launch_amster_job(amster_upload_job_path, ns)
        utils.message('\nWaiting for amster job to complete. This can take several minutes.')
        utils.run('kubectl', f'-n {ns} wait --for=condition=complete job/amster --timeout=600s')
        if printlogs:
            utils.message('Captured logs from the amster pod')
            utils.run('kubectl', f'-n {ns} logs -c amster {pod}')
    finally:
        clean_amster_job(ns, False)

def amster_export(ns, dst, glob, retain):
    kustomize_dir = os.path.join(sys.path[0], '../kustomize')
    amster_export_job_path = os.path.join(kustomize_dir,'overlay/7.0/amster-export')
    fqdn = utils.get_fqdn(ns)
    if not os.path.isdir(dst):
        utils.error(f'{dst} is not a valid directory. Please specify a valid path and try again')
        sys.exit(1)
    try:
        clean_amster_job(ns, retain)
        # Create export - amster will export data, and wait.
        pod = _launch_amster_job(amster_export_job_path, ns)
        utils.message('\nWaiting for amster job to complete. This can take several minutes.')
        utils.run('kubectl', f'-n {ns} wait --for=condition=ready pod {pod} --timeout=600s')

        # If args.glob is True, copy the realm AND global data
        if glob:
            utils.run('kubectl', f'-n {ns} cp -c pause {pod}:/var/tmp/amster {dst}')
        else:
            utils.run('kubectl', f'-n {ns} cp -c pause {pod}:/var/tmp/amster/realms {dst}/realms')

        if not os.listdir(dst):
            utils.error('No files were exported!')
            sys.exit(1)
        utils.message('Updating amster config.')
        for conf_file in pathlib.Path(dst).resolve().rglob('*.json'):
            with conf_file.open('r+') as fp:
                try:
                    conf = json.load(fp)
                    conf = upgrade_amster_conf(conf, pathlib.Path(fp.name), fqdn)
                    fp.seek(0)
                    fp.truncate()
                    json.dump(conf, fp, indent=2, sort_keys=True)
                except Exception as e:
                    utils.error(f'Error with {fp.name} \n\n {e}')
                    sys.exit(1)
        utils.message('Updating amster config complete.')
    finally:
        clean_amster_job(ns, retain)

def upgrade_amster_conf(conf, conf_file_name, fqdn):
    """
    Recursively search objects looking at values and keys that need
    to be updated.
    """

    # Go through all items in a list
    if isinstance(conf, list):
        new_value = []
        for i in conf:
            new_value.append(upgrade_amster_conf(i, conf_file_name, fqdn))
        return new_value
    if isinstance(conf, str):
        try:
            if fqdn in conf:
                return conf.replace(fqdn, '&{fqdn}')
            else:
                return conf
        except TypeError:
            # this happens if there's value of none.
            return conf
    # This is str, int, bool, float and nulls we don't do anything with these
    # types.
    # base case for recursion, eg. the stopping point
    elif not isinstance(conf, dict):
        return conf

    # use copy to iterate through so we can modify keys.
    # check each key and value. Find keys that need placeholdering
    # we should only place holder values that are strings, if the value is a
    # dict or list, recurse on the value.
    for k, v in conf.copy().items():
        if isinstance(v, dict):
            conf[k] = upgrade_amster_conf(v, conf_file_name, fqdn)
            continue
        elif isinstance(v, list):
            new_value = upgrade_amster_conf(v, conf_file_name, fqdn)
            conf[k] = new_value
            continue
        # Key based updates for well known keys:
        # userpassword, amsterVersion, userpassword-encrypted
        if k == 'userpassword-encrypted':
            conf.pop(k)
        elif k == 'userpassword':
            try:
                conf[k] = USER_PWD_EXPR_RULES[conf_file_name.name]
            except KeyError:
                utils.message(
                    (f'A userpassword key found in {conf_file_name} '
                     'but no replacement rule was found, using default'))
                path_parts = conf_file_name.parent.parts
                start = path_parts.index('realms')
                dotted_path = '.'.join(path_parts[start:])
                safe_path = utils.ALLOWED_COMMONS_CHARS.sub('', dotted_path)
                safe_name = utils.ALLOWED_COMMONS_CHARS.sub('', conf_file_name.stem)
                conf[k] = f'&{{{safe_path}.{safe_name}.userpassword}}'
                utils.message(f'{conf_file_name} has password changed to {conf[k]}')
        # update amster version
        elif k == 'amsterVersion':
            conf[k] = '&{version}'
    return conf

# Launch an amster job specified. Provide the path to the kustomize for the amster job. Returns the pod name.
def _launch_amster_job(kustomize_path, ns):
    utils.message('Deploying amster')
    _, contents, _ = utils.run('kustomize', f'build {kustomize_path}', cstdout=True)
    contents = contents.decode('ascii')
    contents = contents.replace('namespace: default', f'namespace: {ns}')
    utils.run('kubectl', f'-n {ns} apply -f -', stdin=bytes(contents, 'ascii'))
    time.sleep(5) # Allow kube-scheduler to create the pod
    _, amster_pod_name, _ = utils.run('kubectl', f'-n {ns} get pods -l app.kubernetes.io/name=amster -o jsonpath={{.items[0].metadata.name}}',
                                      cstdout=True)
    return amster_pod_name.decode('ascii')

def clean_amster_job(ns, retain):
    if not retain:
        utils.message(f'Cleaning up amster components')
        utils.run('kubectl', f'-n {ns} delete --ignore-not-found=true job amster')
        utils.run('kubectl', f'-n {ns} delete --ignore-not-found=true cm amster-import')
    if os.path.exists('amster-import.tar.gz'):
        os.remove('amster-import.tar.gz')
    return

def main():
    common = argparse.ArgumentParser(add_help=False)
    common.add_argument('-n', '--namespace', default='',
                        help='target namespace (default: current namespace)')
    parser = argparse.ArgumentParser(
        description='amster import or export json configuration files')
    subparser = parser.add_subparsers(dest='cmd', required=True, help='select action to perform')
    parser_import = subparser.add_parser('import', help='import json configuration files into AM', parents=[common])
    parser_import.add_argument('src', help='source file or directory to import')
    parser_export = subparser.add_parser('export', help='export files from amster', parents=[common])
    parser_export.add_argument('--global', dest='glob', action='store_true', help='include the global/ configuration in the amster export')
    parser_export.add_argument('--retain', dest='retain', action='store_true', help='retain amster pods for troubleshooting')
    parser_export.add_argument('dst', help='destination directory to export files to')
    subparser.add_parser('clean', help='clean up and remove any amster pods', parents=[common])
    subparser.add_parser('run', help='run amster pod to allow for troubleshooting', parents=[common])

    args = parser.parse_args()
    ctx_namespace = utils.get_namespace()
    namespace = getattr(args, 'namespace', None) or ctx_namespace

    if args.cmd == 'clean':
        clean_amster_job(namespace, False)

    # Import files into amster.
    if args.cmd == 'import':
        amster_import(namespace, args.src)
        return

    # Export files out of amster
    if args.cmd == 'export':
        amster_export(namespace, args.dst, args.glob, args.retain)
        return

    # Run amster pod indefinitely for troubleshooting purposes
    if args.cmd == 'run':
        amster_run(namespace)
        return

if __name__ == '__main__':
    main()
