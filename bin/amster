#!/usr/bin/python3
# Script to import or export dynamic configuration files from AM using an amster Kubernetes job.
# This must be run in the same namespace as AM. The amster pod expects to find the amster secret key
# (generated by secret agent) in the namespace.
import argparse
import utils
import os
import sys
import time
import json
import pathlib

USER_PWD_EXPR_RULES = {
    'idm-provisioning.json': '&{idm.provisioning.client.secret|openidm}',
    'idm-resource-server.json': '&{idm.rs.client.secret|password}',
    'resource-server.json': '&{ig.rs.client.secret|password}',
    'oauth2.json': '&{pit.client.secret|password}',
    'ig-agent.json': '&{ig.agent.password|password}',
}

log = utils.logger(name='amster')

def amster_run(ns):
    utils.message('starting...')
    kustomize_dir = os.path.join(sys.path[0], '..', 'kustomize')
    docker_dir = os.path.join(sys.path[0], '..', 'docker')
    amster_run_job_path = os.path.join(kustomize_dir, 'overlay', 'amster-run')
    amster_scripts_path = os.path.join(docker_dir, 'amster', 'scripts')
    try:
        utils.clean_amster_job(ns, False)
        envVars = os.environ
        envVars['COPYFILE_DISABLE'] = '1'  #skips "._" files in macOS.
        utils.run('tar', f'-czf amster-scripts.tar.gz -C {amster_scripts_path} .', cstdout=True, env=envVars)
        utils.run('kubectl', f'-n {ns} create cm amster-files --from-file=amster-scripts.tar.gz')
        pod = _launch_amster_job(amster_run_job_path, ns)
        utils.message('\nWaiting for amster pod to be running. This can take several minutes.')
        utils.run('kubectl', f'-n {ns} wait --for=condition=ready pod {pod} --timeout=600s')
    finally:
        utils.clean_amster_job(ns, True)

def amster_import(ns, src, duration, printlogs=True):
    kustomize_dir = os.path.join(sys.path[0], '..', 'kustomize')
    docker_dir = os.path.join(sys.path[0], '..', 'docker')
    amster_upload_job_path = os.path.join(kustomize_dir, 'overlay', 'amster-upload')
    amster_scripts_path = os.path.join(docker_dir, 'amster', 'scripts')
    retain = True if duration > '200' else False
    # If the source dir/file does not exist exit
    if not os.path.exists(src):
        utils.error(f'Cant read path {src}. Please specify a valid path and try again')
        sys.exit(1)
    try:
        utils.clean_amster_job(ns, False)
        utils.message('Packing and uploading configs')
        envVars = os.environ
        envVars['COPYFILE_DISABLE'] = '1'  #skips "._" files in macOS.
        utils.run('tar', f'-czf amster-import.tar.gz -C {src} .', cstdout=True, env=envVars)
        utils.run('tar', f'-czf amster-scripts.tar.gz -C {amster_scripts_path} .', cstdout=True, env=envVars)
        utils.run('kubectl', f'-n {ns} create cm amster-files --from-file=amster-import.tar.gz --from-file=amster-scripts.tar.gz')
        utils.run('kubectl', f'-n {ns} create cm amster-retain --from-literal=DURATION={duration}')
        pod = _launch_amster_job(amster_upload_job_path, ns)
        utils.message('\nWaiting for amster job to complete. This can take several minutes.')
        utils.run('kubectl', f'-n {ns} wait --for=condition=Ready pod -l app.kubernetes.io/name=amster --timeout=600s')
        if printlogs:
            utils.message('Captured logs from the amster pod')
            utils.run('kubectl', f'-n {ns} logs -c amster {pod}')
    finally:
        utils.clean_amster_job(ns, retain)

def amster_export(ns, dst, glob, full, duration):
    kustomize_dir = os.path.join(sys.path[0], '..', 'kustomize')
    docker_dir = os.path.join(sys.path[0], '..', 'docker')
    amster_export_job_path = os.path.join(kustomize_dir, 'overlay', 'amster-export')
    amster_scripts_path = os.path.join(docker_dir, 'amster', 'scripts')
    retain = True if duration > '200' else False
    fqdn = utils.get_fqdn(ns)
    if not os.path.isdir(dst):
        utils.error(f'{dst} is not a valid directory. Please specify a valid path and try again')
        sys.exit(1)
    try:
        utils.clean_amster_job(ns, False)
        utils.message('Packing and uploading configs')
        envVars = os.environ
        envVars['COPYFILE_DISABLE'] = '1'  #skips "._" files in macOS.
        utils.run('tar', f'-czf amster-scripts.tar.gz -C {amster_scripts_path} .', cstdout=True, env=envVars)
        utils.run('kubectl', f'-n {ns} create cm amster-files --from-file=amster-scripts.tar.gz')
        if full:
            utils.run('kubectl', f'-n {ns} create cm amster-export-type --from-literal=export=full')
        else:
            utils.run('kubectl', f'-n {ns} create cm amster-export-type --from-literal=export=partial')
        utils.run('kubectl', f'-n {ns} create cm amster-retain --from-literal=DURATION={duration}')
        # Create export - amster will export data, and wait.
        pod = _launch_amster_job(amster_export_job_path, ns)
        utils.message('\nWaiting for amster job to complete. This can take several minutes.')
        utils.run('kubectl', f'-n {ns} wait --for=condition=ready pod {pod} --timeout=600s')

        # If args.glob is True, copy the realm AND global data
        if glob:
            utils.run('kubectl', f'-n {ns} cp -c pause {pod}:/var/tmp/amster {dst}')
        else:
            utils.run('kubectl', f'-n {ns} cp -c pause {pod}:/var/tmp/amster/realms {dst}/realms')

        if not os.listdir(dst):
            utils.error('No files were exported!')
            sys.exit(1)
        upgrade_all_amster_files(dst, fqdn)
    finally:
        utils.clean_amster_job(ns, retain)

def upgrade_all_amster_files(conf_path, fqdn):
    utils.message('Updating amster config.')
    for conf_file in pathlib.Path(conf_path).resolve().rglob('*.json'):
        with conf_file.open('r+') as fp:
            try:
                conf = json.load(fp)
                log.debug(f'Updating amster config {fp.name}')
                conf = upgrade_amster_conf(conf, pathlib.Path(fp.name), fqdn)
                fp.seek(0)
                fp.truncate()
                json.dump(conf, fp, indent=2, sort_keys=True)
            except Exception as e:
                log.error(f'Error with {fp.name} \n\n {e}')
    utils.message('Updating amster config complete.')

def upgrade_amster_conf(conf, conf_file_name, fqdn):
    """
    Recursively search objects looking at values and keys that need
    to be updated.
    """
    # Go through all items in a list
    if isinstance(conf, list):
        new_value = []
        for i in conf:
            new_value.append(upgrade_amster_conf(i, conf_file_name, fqdn))
        return new_value
    if isinstance(conf, str):
        try:
            if fqdn in conf:
                return conf.replace(fqdn, '&{fqdn}')
            else:
                return conf
        except TypeError:
            # this happens if there's value of none.
            return conf
    # This is str, int, bool, float and nulls we don't do anything with these
    # types.
    # base case for recursion, eg. the stopping point
    elif not isinstance(conf, dict):
        return conf

    # use copy to iterate through so we can modify keys.
    # check each key and value. Find keys that need placeholdering
    # we should only place holder values that are strings, if the value is a
    # dict or list, recurse on the value.
    for k, v in conf.copy().items():
        if isinstance(v, dict):
            conf[k] = upgrade_amster_conf(v, conf_file_name, fqdn)
            continue
        elif isinstance(v, list):
            conf[k] = upgrade_amster_conf(v, conf_file_name, fqdn)
            continue
        # Key based updates for well known keys:
        # userpassword, amsterVersion, userpassword-encrypted
        if k == 'userpassword-encrypted':
            conf.pop(k)
        elif k == 'userpassword':
            try:
                conf[k] = USER_PWD_EXPR_RULES[conf_file_name.name]
                # log.debug(f'Updated {conf_file_name.name}')
            except KeyError:
                log.info(
                    (f'A userpassword key found in {conf_file_name} '
                     'but no replacement rule was found, using default'))
                path_parts = conf_file_name.parent.parts
                start = path_parts.index('realms')
                dotted_path = '.'.join(path_parts[start:])
                safe_path = utils.ALLOWED_COMMONS_CHARS.sub('', dotted_path)
                safe_name = utils.ALLOWED_COMMONS_CHARS.sub('', conf_file_name.stem)
                conf[k] = f'&{{{safe_path}.{safe_name}.userpassword}}'
                log.info(f'{conf_file_name} has password changed to {conf[k]}')
        # update amster version
        elif k == 'amsterVersion':
            conf[k] = '&{version}'
    return conf

# Launch an amster job specified. Provide the path to the kustomize for the amster job. Returns the pod name.
def _launch_amster_job(kustomize_path, ns):
    utils.message('Deploying amster')
    _, contents, _ = utils.run('kustomize', f'build {kustomize_path}', cstdout=True)
    contents = contents.decode('ascii')
    contents = contents.replace('namespace: default', f'namespace: {ns}')
    utils.run('kubectl', f'-n {ns} apply -f -', stdin=bytes(contents, 'ascii'))
    time.sleep(5) # Allow kube-scheduler to create the pod
    _, amster_pod_name, _ = utils.run('kubectl', f'-n {ns} get pods -l app.kubernetes.io/name=amster -o jsonpath={{.items[0].metadata.name}}',
                                      cstdout=True)
    return amster_pod_name.decode('ascii')

def main():
    common = argparse.ArgumentParser(add_help=False)
    common.add_argument('-n', '--namespace', default='',
                        help='Target namespace (default: current namespace)')
    parser = argparse.ArgumentParser(
        description='amster import or export json configuration files')
    subparser = parser.add_subparsers(dest='cmd', required=True, help='select action to perform')
    parser_import = subparser.add_parser('import', help='Import json configuration files into AM', parents=[common])
    parser_import.add_argument('src', help='source file or directory to import')
    parser_import.add_argument('--retain', '-r', dest='duration', default='100', help='keep amster pod running for a number of seconds. Add "infinity" to keep up indefinitely')
    parser_export = subparser.add_parser('export', help='export files from amster', parents=[common])
    parser_export.add_argument('--global', dest='glob', action='store_true', help='include the global/ configuration in the amster export')
    parser_export.add_argument('--full', dest='full', action='store_true', help='export all realm configuration')
    parser_export.add_argument('--retain', '-r', dest='duration', default='100', help='keep amster pod running for a number of seconds. Add "infinity" to keep up indefinitely')
    parser_export.add_argument('dst', help='destination directory to export files to')
    subparser.add_parser('clean', help='clean up and remove amster pods', parents=[common])
    parser_upgrade = subparser.add_parser('upgrade', help='replace placeholders of given configs')
    parser_upgrade.add_argument('src', help='source file or directory to update')
    parser_upgrade.add_argument('--fqdn', help='set the FQDN to use as placeholder', required=True)
    subparser.add_parser('run', help='run amster pod to allow for troubleshooting', parents=[common])
    args = parser.parse_args()
    ctx_namespace = utils.get_namespace()
    namespace = getattr(args, 'namespace', None) or ctx_namespace

    if args.cmd == 'clean':
        utils.clean_amster_job(namespace, False)

    # Import files into amster.
    if args.cmd == 'import':
        amster_import(namespace, args.src, args.duration)
        return

    # Export files out of amster
    if args.cmd == 'export':
        amster_export(namespace, args.dst, args.glob, args.full, args.duration)
        return

    # Replace placeholders
    if args.cmd == 'upgrade':
        upgrade_all_amster_files(args.src, args.fqdn)
        return

    # Run amster pod indefinitely for troubleshooting purposes
    if args.cmd == 'run':
        amster_run(namespace)
        return

if __name__ == '__main__':
    main()
