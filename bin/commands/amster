#!/usr/bin/python3
# Script to import or export dynamic configuration files from PingAM using an amster Kubernetes job.
# This must be run in the same namespace as PingAM. The amster pod expects to find the amster secret key
# (generated by secret agent) in the namespace.
import argparse
import os
import sys
import time
import json
import pathlib
from pathlib import Path
import site

file_name = Path(__file__)
current_file_path = file_name.parent.resolve()
root_path = [parent_path for parent_path in current_file_path.parents if (parent_path / 'README.md').exists()][0]
dependencies_dir = os.path.join(root_path, 'lib', 'dependencies')
# Insert lib folders to python path
sys.path.insert(0, str(root_path))
sys.path.insert(1, str(dependencies_dir) + site.USER_SITE.replace(site.USER_BASE, ''))

from lib.python import utils

USER_PWD_EXPR_RULES = {
    'idm-provisioning.json': '&{idm.provisioning.client.secret|YbDtETPLkGJDtOiy}',
    'idm-resource-server.json': '&{idm.rs.client.secret|YbDtETPLkGJDtOiy}',
    'resource-server.json': '&{ig.rs.client.secret|YbDtETPLkGJDtOiy}',
    'oauth2.json': '&{pit.client.secret|YbDtETPLkGJDtOiy}',
    'ig-agent.json': '&{ig.agent.password|YbDtETPLkGJDtOiy}',
}

log = utils.logger(name='amster')

def amster_run(ns, kustomize_path, scripts_path, env_name):
    utils.message('starting...')
    amster_run_job_path = kustomize_path / 'overlay' / env_name / 'amster' / 'run'

    utils.clean_amster_job(ns)
    envVars = os.environ
    envVars['COPYFILE_DISABLE'] = '1'  #skips "._" files in macOS.
    utils.run('tar', f'-czf amster-scripts.tar.gz -C {scripts_path} .', cstdout=True, env=envVars)
    utils.run('kubectl', f'-n {ns} create cm amster-files --from-file=amster-scripts.tar.gz')
    pod = _launch_amster_job(amster_run_job_path, ns)
    utils.message('\nWaiting for amster pod to be running. This can take several minutes.')
    utils.run('kubectl', f'-n {ns} wait --for=condition=ready pod {pod} --timeout=600s')

def amster_import(ns, src, kustomize_path, scripts_path, env_name, printlogs=True):
    amster_upload_job_path = kustomize_path / 'overlay' / env_name / 'amster' / 'upload'
    # If the source dir/file does not exist exit
    if not os.path.exists(src):
        utils.error(f"Can't read path {src}. Please specify a valid path and try again")
        sys.exit(1)
    utils.clean_amster_job(ns)
    utils.message('Packing and uploading configs')
    envVars = os.environ
    envVars['COPYFILE_DISABLE'] = '1'  #skips "._" files in macOS.
    utils.run('tar', f'-czf amster-import.tar.gz -C {src} .', cstdout=True, env=envVars)
    utils.run('tar', f'-czf amster-scripts.tar.gz -C {scripts_path} .', cstdout=True, env=envVars)
    utils.run('kubectl', f'-n {ns} create cm amster-files --from-file=amster-import.tar.gz --from-file=amster-scripts.tar.gz')
    pod = _launch_amster_job(amster_upload_job_path, ns)
    utils.message('\nWaiting for amster job to complete. This can take several minutes.')
    utils.run('kubectl', f'-n {ns} wait --for=condition=Ready pod -l app.kubernetes.io/name=amster --timeout=600s')
    if printlogs:
        utils.message('Captured logs from the amster pod')
        utils.run('kubectl', f'-n {ns} logs -c amster {pod}')

def amster_export(ns, dst, kustomize_path, scripts_path, glob, full, env_name):
    amster_export_job_path = kustomize_path / 'overlay' / env_name / 'amster' / 'export'
    fqdn = utils.get_fqdn(ns)
    if not os.path.isdir(dst):
        utils.error(f'{dst} is not a valid directory. Please specify a valid path and try again')
        sys.exit(1)
    try:
        utils.clean_amster_job(ns)
        utils.message('Packing and uploading configs')
        envVars = os.environ
        envVars['COPYFILE_DISABLE'] = '1'  #skips "._" files in macOS.
        utils.run('tar', f'-czf amster-scripts.tar.gz -C {scripts_path} .', cstdout=True, env=envVars)
        utils.run('kubectl', f'-n {ns} create cm amster-files --from-file=amster-scripts.tar.gz')
        if full:
            utils.run('kubectl', f'-n {ns} create cm amster-export-type --from-literal=export=full')
        else:
            utils.run('kubectl', f'-n {ns} create cm amster-export-type --from-literal=export=partial')
        # Create export - amster will export data, and wait.
        pod = _launch_amster_job(amster_export_job_path, ns)
        utils.message('\nWaiting for amster job to complete. This can take several minutes.')
        utils.run('kubectl', f'-n {ns} wait --for=condition=ready pod {pod} --timeout=600s')

        # If args.glob is True, copy the realm AND global data
        if glob:
            utils.run('kubectl', f'-n {ns} cp -c pause {pod}:/var/tmp/amster {dst}')
        else:
            utils.run('kubectl', f'-n {ns} cp -c pause {pod}:/var/tmp/amster/realms {dst}/realms')

        if not os.listdir(dst):
            utils.error('No files were exported!')
            sys.exit(1)
        upgrade_all_amster_files(dst, fqdn)
    finally:
        utils.clean_amster_job(ns)

def upgrade_all_amster_files(conf_path, fqdn):
    utils.message('Updating amster config.')
    for conf_file in pathlib.Path(conf_path).resolve().rglob('*.json'):
        with conf_file.open('r+') as fp:
            try:
                conf = json.load(fp)
                log.debug(f'Updating amster config {fp.name}')
                conf = upgrade_amster_conf(conf, pathlib.Path(fp.name), fqdn)
                fp.seek(0)
                fp.truncate()
                json.dump(conf, fp, indent=2, sort_keys=True)
            except Exception as e:
                log.error(f'Error with {fp.name} \n\n {e}')
    utils.message('Updating amster config complete.')

def upgrade_amster_conf(conf, conf_file_name, fqdn):
    """
    Recursively search objects looking at values and keys that need
    to be updated.
    """
    # Go through all items in a list
    if isinstance(conf, list):
        new_value = []
        for i in conf:
            new_value.append(upgrade_amster_conf(i, conf_file_name, fqdn))
        return new_value
    if isinstance(conf, str):
        try:
            if fqdn in conf:
                return conf.replace(fqdn, '&{fqdn}')
            else:
                return conf
        except TypeError:
            # this happens if there's value of none.
            return conf
    # This is str, int, bool, float and nulls we don't do anything with these
    # types.
    # base case for recursion, eg. the stopping point
    elif not isinstance(conf, dict):
        return conf

    # use copy to iterate through so we can modify keys.
    # check each key and value. Find keys that need placeholdering
    # we should only place holder values that are strings, if the value is a
    # dict or list, recurse on the value.
    for k, v in conf.copy().items():
        if isinstance(v, dict):
            conf[k] = upgrade_amster_conf(v, conf_file_name, fqdn)
            continue
        elif isinstance(v, list):
            conf[k] = upgrade_amster_conf(v, conf_file_name, fqdn)
            continue
        # Key based updates for well known keys:
        # userpassword, amsterVersion, userpassword-encrypted
        if k == 'userpassword-encrypted':
            conf.pop(k)
        elif k == 'userpassword':
            try:
                conf[k] = USER_PWD_EXPR_RULES[conf_file_name.name]
                # log.debug(f'Updated {conf_file_name.name}')
            except KeyError:
                log.info(
                    (f'A userpassword key found in {conf_file_name} '
                     'but no replacement rule was found, using default'))
                path_parts = conf_file_name.parent.parts
                start = path_parts.index('realms')
                dotted_path = '.'.join(path_parts[start:])
                safe_path = utils.ALLOWED_COMMONS_CHARS.sub('', dotted_path)
                safe_name = utils.ALLOWED_COMMONS_CHARS.sub('', conf_file_name.stem)
                conf[k] = f'&{{{safe_path}.{safe_name}.userpassword}}'
                log.info(f'{conf_file_name} has password changed to {conf[k]}')
        # update amster version
        elif k == 'amsterVersion':
            conf[k] = '&{version}'
    return conf

# Launch an amster job specified. Provide the path to the kustomize for the amster job. Returns the pod name.
def _launch_amster_job(kustomize_path, ns):
    utils.message('Deploying amster')
    _, contents, _ = utils.run('kustomize', f'build {kustomize_path}', cstdout=True)
    contents = contents.decode('ascii')
    contents = contents.replace('namespace: default', f'namespace: {ns}')
    utils.run('kubectl', f'-n {ns} apply -f -', stdin=bytes(contents, 'ascii'))
    time.sleep(5) # Allow kube-scheduler to create the pod
    _, amster_pod_name, _ = utils.run('kubectl', f'-n {ns} get pods -l app.kubernetes.io/name=amster -o jsonpath={{.items[0].metadata.name}}',
                                      cstdout=True)
    return amster_pod_name.decode('ascii')

def main():
    common = argparse.ArgumentParser(add_help=False)
    common.add_argument('-n', '--namespace', default='',
                        help='Target namespace (default: current namespace)')
    common.add_argument('-b', '--build-path', default=argparse.SUPPRESS,
                        help='Docker dir to use [absolute or relative to forgeops root] (default: docker)')
    common.add_argument('-H', '--helm-path', default=argparse.SUPPRESS,
                        help='Dir to store Helm values files [absolute or relative to forgeops root] (default: helm)')
    common.add_argument('-k', '--kustomize-path', default=argparse.SUPPRESS,
                        help='Kustomize dir to use [absolute or relative to forgeops root] (default: kustomize)')
    common.add_argument('-e', '--env-name', required=True, help='Name of environment to manage')
    parser = argparse.ArgumentParser(
        description='amster import or export json configuration files')
    subparser = parser.add_subparsers(dest='cmd', required=True, help='select action to perform')
    parser_import = subparser.add_parser('import', help='Import json configuration files into PingAM', parents=[common])
    parser_import.add_argument('src', help='source file or directory to import')
    parser_export = subparser.add_parser('export', help='export files from amster', parents=[common])
    parser_export.add_argument('--global', dest='glob', action='store_true', help='include the global/ configuration in the amster export')
    parser_export.add_argument('--full', dest='full', action='store_true', help='export all realm configuration')
    parser_export.add_argument('dst', help='destination directory to export files to')
    subparser.add_parser('clean', help='clean up and remove amster pods', parents=[common])
    parser_upgrade = subparser.add_parser('upgrade', help='replace placeholders of given configs')
    parser_upgrade.add_argument('src', help='source file or directory to update')
    parser_upgrade.add_argument('--fqdn', help='set the FQDN to use as placeholder', required=True)
    subparser.add_parser('run', help='run amster pod to allow for troubleshooting', parents=[common])
    args = parser.parse_args()
    ctx_namespace = utils.get_namespace()
    namespace = getattr(args, 'namespace', None) or ctx_namespace

    overrides = utils.process_overrides(root_path,
                                        getattr(args, 'helm_path', None),
                                        getattr(args, 'kustomize_path', None),
                                        getattr(args, 'build_path', None),
                                        getattr(args, 'no_helm', False),
                                        getattr(args, 'no_kustomize', False),
                                        getattr(args, 'releases_src', None),
                                        getattr(args, 'pull_policy', None),
                                        getattr(args, 'source', None),
                                        getattr(args, 'ssl_secretname', None))
    kustomize_path = overrides['kustomize_path']
    scripts_path = overrides['build_path'] / 'amster' / 'scripts'

    if args.cmd == 'clean':
        utils.clean_amster_job(namespace)

    # Import files into amster.
    if args.cmd == 'import':
        src = None
        if Path(args.src).is_absolute():
            src = Path(args.src)
        else:
            src = root_path / args.src

        amster_import(namespace, src, kustomize_path, scripts_path, args.env_name)
        return

    # Export files out of amster
    if args.cmd == 'export':
        dst = None
        if Path(args.dst).is_absolute():
            dst = Path(args.dst)
        else:
            dst = overrides['forgeops_data'] / args.dst

        amster_export(namespace, dst, kustomize_path, scripts_path, args.glob, args.full, args.env_name)
        return

    # Replace placeholders
    if args.cmd == 'upgrade':
        if Path(args.src).is_absolute():
            src = Path(args.src)
        else:
            src = overrides['forgeops_data'] / args.src

        upgrade_all_amster_files(args.src, args.fqdn)
        return

    # Run amster pod indefinitely for troubleshooting purposes
    if args.cmd == 'run':
        amster_run(namespace, kustomize_path, scripts_path, args.env_name)
        return

if __name__ == '__main__':
    main()
