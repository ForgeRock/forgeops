#!/usr/bin/env python3
import argparse
import pathlib
import subprocess
import shutil
import io
import tarfile
import json
import re
import sys
import textwrap

import utils

HELP_DESCRIPTION = """
Manage ForgeRock Platform configuration.
"""
HELP_EXPORT_CMD_DESCRIPTION = """
Export config from running instance to a given profile.
"""
HELP_CMD_COMPONENTS = """
ForgeRock Identity Platform component.
"""
HELP_EXPORT_CMD_SORT = """
Sort configuration json alphanumerically. This will lead to a large initial
 diff but subsequent iterations should be smaller and more readable.
"""
HELP_PATH_CMD_TOOL_NAME = """
Directory of tool configuration files e.g. docker, kustomize
"""
HELP_PATH_CMD_DESCRIPTION = """
Resolve an absolute path to a location in the forgeops directory tree.
"""

HELP_PATH_DOCKER_CMD = """
Resolve the path to a directory which contains a Dockerfile, optionally resolve
 the path for a config profile used in a Dockerfile.
"""
HELP_PATH_DOCKER_PROFILE_NAME = """
Add the config profile name to the path.
"""

HELP_PATH_KUSTOMIZE_CMD = """
Resolve the path to a directory which contains kustomization
 directories that hold many manifests. Optionally resolve to profile. e.g.
 small.
"""

HELP_PATH_KUSTOMIZE_LAYER = """
The parent directory containing multiple kustomize profile directories.
  e.g. base or overlay
"""

HELP_PATH_KUSTOMIZE_PROFILE = """
Directory which contians a kustomization.yaml. e.g. small,medium,large
"""

HELP_PATH_KUSTOMIZE_SUBPROFILE = """
Directory which contians a kustomization.yaml, this is used for variant images
like ds which has multiple kustomizations. e.g cts,idrepo,base
""".strip()

HELP_PATH_EXAMPLES = """
examples:
  # Path to the "small" kustomize profile
  $ ./bin/config path kustomize overlay small

  # Path to a IDM configuration profile
  $ ./bin/config path docker idm idm-only

  # Path to the directory containing IG Dockerfile
  $ ./bin/config path docker ig
"""

HELP_EXPORT_EXAMPLES = """
examples:
  # Export AM configuration to an existing profile <myprofile>
  $ ./bin/config export am <myprofile>

  # Export AM configruation for a profile that doesn't exist
  $ ./bin/config export --baseline-profile cdk am <mynewprofile>
"""

PLATFORM_COMPONENTS = {
    'am': ('am',),
    'amster': ('amster',),
    'idm': ('idm',),
    'ig': ('ig',),
    'ds': ('ds',),
}

APP_CONF_PATH_FMT = {
    'am': 'am/config-profiles/{profile}'.format,
    'idm': 'idm/config-profiles/{profile}/conf'.format,
    'ig': 'ig/config-profiles/{profile}/config'.format,
    'amster': 'amster/config-profiles/{profile}/config'.format,
}
USER_PWD_EXPR_RULES = {
    'idm-provisioning.json': '&{idm.provisioning.client.secret|openidm}',
    'idm-resource-server.json': '&{idm.rs.client.secret|password}',
    'resource-server.json': '&{ig.rs.client.secret|password}',
    'oauth2.json': '&{pit.client.secret|password}',
    'ig-agent.json': '&{ig.agent.password|password}',
}

KUBECTL = shutil.which('kubectl')
AMSTER_BIN = utils.SCRIPT_DIR.joinpath('amster').resolve()
AM_UPGRADER = utils.SCRIPT_DIR.joinpath('am-config-upgrader').resolve()


def profile_path(path):
    """Make sure there's a profile directory"""
    if path.is_dir():
        log.info(f'Updating existing profile: {path}')
    else:
        log.info(f'Creating a new profile: {path}')
        path.mkdir(parents=True)


def export_amster(conf):
    profile_path(conf)
    try:
        utils.run(AMSTER_BIN, f'export {conf}')
    except utils.RunError as e:
        log.error(f'{e.cmd} had the following error: \n {e.stderr}')
        raise Exception('Couldn\'t run amster export')


def convert_path_to_common_exp(path):
    """
    This changes:
      docker/amster/foo/conf/realms/root-philA/OAuth2Clients/b.json
      realms.rootphilA.oauth2clients.b.userpassword
    """
    path_parts = path.parent.parts
    start = path_parts.index('conf')
    dotted_path = '.'.join(path_parts[start + 1:])
    safe_path = ALLOWED_COMMONS_CHARS.sub('', dotted_path)
    safe_name = ALLOWED_COMMONS_CHARS.sub('', path.stem)
    return f'&{{{safe_path}.{safe_name}.userpassword}}'


def upgrade_amster(conf_path):
    fqdn = utils.get_configmap_value(
        utils.get_namespace(None), 'platform-config', 'FQDN')
    for conf_file in conf_path.rglob('*.json'):
        with conf_file.open('r+') as fp:
            try:
                conf = json.load(fp)
                log.debug(f'Updating amster config {fp.name}')
                conf = utils.upgrade_amster_conf(conf,
                                                 pathlib.Path(fp.name),
                                                 fqdn)
                fp.seek(0)
                fp.truncate()
                json.dump(conf, fp)
            except Exception as e:
                log.error(f'Error with {fp.name} \n\n {e}')


def export_idm(idm_conf, pod_name):
    """Export IDM config"""
    profile_path(idm_conf)
    # Copy from the IDM container to a local path
    cp_args = f"""
    cp -c openidm
        {pod_name}:/opt/openidm/conf {idm_conf}
    """.strip()
    try:
        utils.run(KUBECTL, cp_args)
    except utils.RunError as e:
        log.error(f'{e.cmd} had the following error: \n {e.stderr}')


def export_am(am_conf, pod_name):
    profile_path(am_conf)
    # Copy from the am container to a local path
    exec_args = f"""
        exec {pod_name} -- /home/forgerock/export-diff.sh -
    """.strip()
    try:
        log.debug('Starting export')
        _, out, _ = utils.run(KUBECTL, exec_args, cstdout=True, cstderr=True)
        if out == b'':
            raise Exception('No configuration changes found.')
        f = io.BytesIO(out)
        with tarfile.open(fileobj=f) as tarball:
            log.debug('Starting to extract tarball')
            tarball.extractall(am_conf)
            log.debug('Export Completed.')
        log.info('Exported AM config')

    except utils.RunError as e:
        log.error(f'{e.cmd} had the following error: \n {e.stderr}')
        raise e
    except tarfile.ExtractError as e:
        log.error(f'Couldn\'t extract tarball')
        raise e


def upgrade_am(am_conf):
    """Run AM configuration through the AM control"""
    try:
        utils.run(AM_UPGRADER, str(am_conf))
    except utils.RunError as e:
        log.error(f'Error during upgrade {e.stderr}')

    log.info('Completed upgrading AM configuration')


def export_ig(ig_conf, pod_name):
    """Export IG config"""
    profile_path(ig_conf)
    # Copy from the IG container to a local path
    cp_args = f"""
    cp -c ig {pod_name}:/var/ig/config {ig_conf}
    """.strip()
    try:
        utils.run(KUBECTL, cp_args)
    except utils.RunError as e:
        log.error(f'{e.cmd} had the following error: \n {e.stderr}')
        raise e


def run_export(args):
    # Amster doesn't use a running instance
    conf_path = pathlib.Path(utils.DOCKER_BASE_PATH.joinpath(
        APP_CONF_PATH_FMT[args.component](profile=args.profile))).resolve()
    # prime the config
    if not conf_path.exists():
        name = f'config-profiles/{args.profile}'
        cdk = 'config-profiles/cdk'
        error_msg = textwrap.fill('You\'re attempting to export configuration to a profile that doesn\'t exist. You should "prime" your config by doing the following:', width=120)
        cmd = textwrap.indent(f'\ncp -r {utils.DOCKER_BASE_PATH.joinpath(args.component, cdk)} {utils.DOCKER_BASE_PATH.joinpath(args.component, name)}', ' $ ')
        log.error(error_msg + cmd)
        sys.exit(1)
    if args.component == 'amster':
        amster_path = APP_CONF_PATH_FMT['amster'](profile=args.profile)
        log.info('Exporting amster config.')
        export_amster(conf_path)
        log.info('Updating amster config.')
        upgrade_amster(conf_path)
        log.info('Updating amster config complete.')
    # Configs from running containers
    else:
        jsonpath_expr = """
        {range .items[*]}{.metadata.labels.app}{' '}{.metadata.name}{'\\n'}{end}
        """.strip()
        pod_name_args = f"""
        get -l "app={args.component}" -o jsonpath="{jsonpath_expr}" pod
        """.strip()
        try:
            _, out, _ = utils.run(KUBECTL, pod_name_args,
                                  cstdout=True, cstderr=True)
            log.debug('Gathered pod names.')
        except subprocess.CalledProcessError as e:
            log.error(f'{e.cmd} had the following error: \n {e.stderr}')
            sys.exit(1)

        # IDM, AM, IG export types
        try:
            component_name, pod_name = out.splitlines()[0].decode().split(' ')
            log.info(f'Running export for {component_name} in {pod_name}')
            if component_name == 'idm':
                export_idm(conf_path, pod_name)
            elif component_name == 'ig':
                export_ig(conf_path, pod_name)
            elif component_name == 'am':
                export_am(conf_path, pod_name)
                upgrade_am(conf_path)
            log.info('Completed export')
        except IndexError:
            log.error('Unable to find running components.')
            sys.exit(1)
        except Exception as e:
            log.error(e)
            sys.exit(1)

    if args.sort:
        log.info('Sorting configuration.')
        utils.sort_dir_json(conf_path)
        log.info('Sorting completed.')


def run_path(args):
    if args.tool == 'docker' and args.component != 'ds':
        profile = f'config-profiles/{args.profile}' if args.profile != '' else ''
        print(utils.DOCKER_BASE_PATH.joinpath(args.component, profile))
    elif args.tool == 'docker' and args.component == 'ds':
        profile = f'{args.profile}' if args.profile != '' else ''
        print(utils.DOCKER_BASE_PATH.joinpath(args.component, profile))
    elif args.tool == 'kustomize':
        print(utils.KUSTOMIZE_BASE_PATH.joinpath(args.layer, args.kustomization))


def main():
    parser = argparse.ArgumentParser(description=HELP_DESCRIPTION)
    utils.add_loglevel_arg(parser)
    sub_cmd_parser = parser.add_subparsers(dest="cmd")

    # export sub command
    export_cmd_parser = sub_cmd_parser.add_parser('export',
                                                  epilog=textwrap.dedent(
                                                      HELP_EXPORT_EXAMPLES),
                                                  formatter_class=argparse.RawDescriptionHelpFormatter,
                                                  description=HELP_EXPORT_CMD_DESCRIPTION)
    export_cmd_parser.add_argument('component',
                                   choices=PLATFORM_COMPONENTS.keys(),
                                   help=HELP_CMD_COMPONENTS)
    export_cmd_parser.add_argument('profile')
    export_cmd_parser.add_argument('--sort', '-s',
                                   help=HELP_EXPORT_CMD_SORT,
                                   action='store_true',
                                   default=True)
    export_cmd_parser.set_defaults(func=run_export)

    # path sub command
    path_cmd_parser = sub_cmd_parser.add_parser('path',
                                                epilog=textwrap.dedent(
                                                    HELP_PATH_EXAMPLES),
                                                formatter_class=argparse.RawTextHelpFormatter,
                                                description=HELP_PATH_CMD_DESCRIPTION)
    path_sub_cmd_parser = path_cmd_parser.add_subparsers(dest='tool')
    path_cmd_parser.set_defaults(func=run_path)

    # docker paths
    path_docker_parser = path_sub_cmd_parser.add_parser('docker',
                                                        epilog=textwrap.dedent(
                                                            HELP_PATH_EXAMPLES),
                                                        formatter_class=argparse.RawTextHelpFormatter,
                                                        description=HELP_PATH_CMD_DESCRIPTION)
    path_docker_parser.add_argument('component',
                                    help=HELP_CMD_COMPONENTS,
                                    choices=PLATFORM_COMPONENTS.keys())
    path_docker_parser.add_argument('profile',
                                    help=HELP_PATH_DOCKER_PROFILE_NAME,
                                    nargs='?',
                                    default='')

    # kustomize paths
    path_kustomize_parser = path_sub_cmd_parser.add_parser('kustomize',
                                                           epilog=textwrap.dedent(
                                                               HELP_PATH_EXAMPLES),
                                                           formatter_class=argparse.RawTextHelpFormatter,
                                                           description=HELP_PATH_CMD_DESCRIPTION)
    path_kustomize_parser.add_argument('layer',
                                       help=HELP_PATH_KUSTOMIZE_LAYER,
                                       choices=('base', 'overlay'))
    path_kustomize_parser.add_argument('kustomization',
                                       help=HELP_PATH_KUSTOMIZE_PROFILE,
                                       nargs='?',
                                       default='')
    path_kustomize_parser.add_argument('sub-kustomization',
                                       help=HELP_PATH_KUSTOMIZE_SUBPROFILE,
                                       nargs='?',
                                       default='')

    parsed = parser.parse_args()
    global log
    log = utils.logger(level=parsed.log_level)
    parsed.func(parsed)


main()
